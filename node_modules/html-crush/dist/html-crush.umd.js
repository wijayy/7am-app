/**
 * @name html-crush
 * @fileoverview Minify email templates
 * @version 6.1.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/html-crush/}
 */

"use strict";var htmlCrush=(()=>{var Pe=Object.create;var G=Object.defineProperty;var He=Object.getOwnPropertyDescriptor;var Fe=Object.getOwnPropertyNames,ge=Object.getOwnPropertySymbols,_e=Object.getPrototypeOf,me=Object.prototype.hasOwnProperty,xe=Object.prototype.propertyIsEnumerable;var Z=(e,r,l)=>r in e?G(e,r,{enumerable:!0,configurable:!0,writable:!0,value:l}):e[r]=l,w=(e,r)=>{for(var l in r||(r={}))me.call(r,l)&&Z(e,l,r[l]);if(ge)for(var l of ge(r))xe.call(r,l)&&Z(e,l,r[l]);return e};var ke=(e,r)=>()=>(r||e((r={exports:{}}).exports,r),r.exports),We=(e,r)=>{for(var l in r)G(e,l,{get:r[l],enumerable:!0})},ce=(e,r,l,t)=>{if(r&&typeof r=="object"||typeof r=="function")for(let a of Fe(r))!me.call(e,a)&&a!==l&&G(e,a,{get:()=>r[a],enumerable:!(t=He(r,a))||t.enumerable});return e};var fe=(e,r,l)=>(l=e!=null?Pe(_e(e)):{},ce(r||!e||!e.__esModule?G(l,"default",{value:e,enumerable:!0}):l,e)),Je=e=>ce(G({},"__esModule",{value:!0}),e);var ee=(e,r,l)=>Z(e,typeof r!="symbol"?r+"":r,l);var ne=ke(($t,be)=>{"use strict";be.exports=Ue;function W(e){return e instanceof Buffer?Buffer.from(e):new e.constructor(e.buffer.slice(),e.byteOffset,e.length)}function Ue(e){if(e=e||{},e.circles)return Ge(e);let r=new Map;if(r.set(Date,u=>new Date(u)),r.set(Map,(u,s)=>new Map(t(Array.from(u),s))),r.set(Set,(u,s)=>new Set(t(Array.from(u),s))),e.constructorHandlers)for(let u of e.constructorHandlers)r.set(u[0],u[1]);let l=null;return e.proto?i:a;function t(u,s){let g=Object.keys(u),o=new Array(g.length);for(let m=0;m<g.length;m++){let c=g[m],y=u[c];typeof y!="object"||y===null?o[c]=y:y.constructor!==Object&&(l=r.get(y.constructor))?o[c]=l(y,s):ArrayBuffer.isView(y)?o[c]=W(y):o[c]=s(y)}return o}function a(u){if(typeof u!="object"||u===null)return u;if(Array.isArray(u))return t(u,a);if(u.constructor!==Object&&(l=r.get(u.constructor)))return l(u,a);let s={};for(let g in u){if(Object.hasOwnProperty.call(u,g)===!1)continue;let o=u[g];typeof o!="object"||o===null?s[g]=o:o.constructor!==Object&&(l=r.get(o.constructor))?s[g]=l(o,a):ArrayBuffer.isView(o)?s[g]=W(o):s[g]=a(o)}return s}function i(u){if(typeof u!="object"||u===null)return u;if(Array.isArray(u))return t(u,i);if(u.constructor!==Object&&(l=r.get(u.constructor)))return l(u,i);let s={};for(let g in u){let o=u[g];typeof o!="object"||o===null?s[g]=o:o.constructor!==Object&&(l=r.get(o.constructor))?s[g]=l(o,i):ArrayBuffer.isView(o)?s[g]=W(o):s[g]=i(o)}return s}}function Ge(e){let r=[],l=[],t=new Map;if(t.set(Date,g=>new Date(g)),t.set(Map,(g,o)=>new Map(i(Array.from(g),o))),t.set(Set,(g,o)=>new Set(i(Array.from(g),o))),e.constructorHandlers)for(let g of e.constructorHandlers)t.set(g[0],g[1]);let a=null;return e.proto?s:u;function i(g,o){let m=Object.keys(g),c=new Array(m.length);for(let y=0;y<m.length;y++){let h=m[y],$=g[h];if(typeof $!="object"||$===null)c[h]=$;else if($.constructor!==Object&&(a=t.get($.constructor)))c[h]=a($,o);else if(ArrayBuffer.isView($))c[h]=W($);else{let O=r.indexOf($);O!==-1?c[h]=l[O]:c[h]=o($)}}return c}function u(g){if(typeof g!="object"||g===null)return g;if(Array.isArray(g))return i(g,u);if(g.constructor!==Object&&(a=t.get(g.constructor)))return a(g,u);let o={};r.push(g),l.push(o);for(let m in g){if(Object.hasOwnProperty.call(g,m)===!1)continue;let c=g[m];if(typeof c!="object"||c===null)o[m]=c;else if(c.constructor!==Object&&(a=t.get(c.constructor)))o[m]=a(c,u);else if(ArrayBuffer.isView(c))o[m]=W(c);else{let y=r.indexOf(c);y!==-1?o[m]=l[y]:o[m]=u(c)}}return r.pop(),l.pop(),o}function s(g){if(typeof g!="object"||g===null)return g;if(Array.isArray(g))return i(g,s);if(g.constructor!==Object&&(a=t.get(g.constructor)))return a(g,s);let o={};r.push(g),l.push(o);for(let m in g){let c=g[m];if(typeof c!="object"||c===null)o[m]=c;else if(c.constructor!==Object&&(a=t.get(c.constructor)))o[m]=a(c,s);else if(ArrayBuffer.isView(c))o[m]=W(c);else{let y=r.indexOf(c);y!==-1?o[m]=l[y]:o[m]=s(c)}}return r.pop(),l.pop(),o}}});var rt={};We(rt,{crush:()=>nt,defaults:()=>Ce,version:()=>tt});var Be={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function k(e,r){if(!Array.isArray(e)||!e.length)return e;let l=w(w({},Be),r),t,a;if(l.strictlyTwoElementsInRangeArrays&&!e.every((s,g)=>!Array.isArray(s)||s.length!==2?(t=g,a=s.length,!1):!0))throw new TypeError("ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ".concat(t,"th range (").concat(JSON.stringify(e[t],null,4),") has not two but ").concat(a," elements!"));if(!e.every((s,g)=>!Array.isArray(s)||!Number.isInteger(s[0])||s[0]<0||!Number.isInteger(s[1])||s[1]<0?(t=g,!1):!0))throw new TypeError("ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ".concat(t,"th range (").concat(JSON.stringify(e[t],null,4),") does not consist of only natural numbers!"));let i=e.length**2,u=0;return Array.from(e).sort((s,g)=>(l.progressFn&&(u+=1,l.progressFn(Math.floor(u*100/i))),s[0]===g[0]?s[1]<g[1]?-1:s[1]>g[1]?1:0:s[0]<g[0]?-1:1))}var he={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function $e(e,r){function l(o){return!!o&&typeof o=="object"&&!Array.isArray(o)}if(!Array.isArray(e)||!e.length)return null;let t;if(r)if(l(r)){if(t=w(w({},he),r),t.progressFn&&l(t.progressFn)&&!Object.keys(t.progressFn).length)t.progressFn=null;else if(t.progressFn&&typeof t.progressFn!="function")throw new Error('ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "'.concat(typeof t.progressFn,'", equal to ').concat(JSON.stringify(t.progressFn,null,4)));if(![1,2,"1","2"].includes(t.mergeType))throw new Error('ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "'.concat(typeof t.mergeType,'", equal to ').concat(JSON.stringify(t.mergeType,null,4)));if(typeof t.joinRangesThatTouchEdges!="boolean")throw new Error('ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "'.concat(typeof t.joinRangesThatTouchEdges,'", equal to ').concat(JSON.stringify(t.joinRangesThatTouchEdges,null,4)))}else throw new Error("emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n".concat(JSON.stringify(r,null,4)," (type ").concat(typeof r,")"));else t=w({},he);let a=e.filter(o=>Array.isArray(o)).map(o=>[...o]).filter(o=>o[2]!==void 0||o[0]!==o[1]),i,u,s;t.progressFn?i=k(a,{progressFn:o=>{s=Math.floor(o/5),s!==u&&(u=s,t.progressFn(s))}}):i=k(a);let g=i.length-1;for(let o=g;o>0;o--)t.progressFn&&(s=Math.floor((1-o/g)*78)+21,s!==u&&s>u&&(u=s,t.progressFn(s))),(i[o][0]<=i[o-1][0]||!t.joinRangesThatTouchEdges&&i[o][0]<i[o-1][1]||t.joinRangesThatTouchEdges&&i[o][0]<=i[o-1][1])&&(i[o-1][0]=Math.min(i[o][0],i[o-1][0]),i[o-1][1]=Math.max(i[o][1],i[o-1][1]),i[o][2]!==void 0&&(i[o-1][0]>=i[o][0]||i[o-1][1]<=i[o][1])&&i[o-1][2]!==null&&(i[o][2]===null&&i[o-1][2]!==null?i[o-1][2]=null:i[o-1][2]!=null?+t.mergeType==2&&i[o-1][0]===i[o][0]?i[o-1][2]=i[o][2]:i[o-1][2]+=i[o][2]:i[o-1][2]=i[o][2]),i.splice(o,1),o=i.length);return i.length?i:null}var je=!0,te="Invariant failed";function pe(e,r){if(!e){if(je)throw new Error(te);var l=typeof r=="function"?r():r,t=l?"".concat(te,": ").concat(l):te;throw new Error(t)}}function de(e,r,l){let t=0,a=0;if(arguments.length===0)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(typeof e!="string")throw new TypeError("ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ".concat(typeof e,", equal to: ").concat(JSON.stringify(e,null,4)));if(r&&!Array.isArray(r))throw new TypeError("ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ".concat(typeof r,", equal to: ").concat(JSON.stringify(r,null,4)));if(l&&typeof l!="function")throw new TypeError("ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ".concat(typeof l,", equal to: ").concat(JSON.stringify(l,null,4)));if(!(r!=null&&r.filter(m=>m).length))return e;let i;Array.isArray(r)&&Number.isInteger(r[0])&&Number.isInteger(r[1])?i=[Array.from(r)]:i=Array.from(r);let u=i.length,s=0;i.filter(m=>m).forEach((m,c)=>{if(l&&(t=Math.floor(s/u*10),t!==a&&(a=t,l(t))),!Array.isArray(m))throw new TypeError("ranges-apply: [THROW_ID_05] ranges array, second input arg., has ".concat(c,"th element not an array: ").concat(JSON.stringify(m,null,4),", which is ").concat(typeof m));if(!Number.isInteger(m[0])){if(!Number.isInteger(+m[0])||+m[0]<0)throw new TypeError("ranges-apply: [THROW_ID_06] ranges array, second input arg. has ".concat(c,"th element, array ").concat(JSON.stringify(m,null,0),". Its first element is not an integer, string index, but ").concat(typeof m[0],", equal to: ").concat(JSON.stringify(m[0],null,4),"."));i[c][0]=+i[c][0]}if(!Number.isInteger(m[1])){if(!Number.isInteger(+m[1])||+m[1]<0)throw new TypeError("ranges-apply: [THROW_ID_07] ranges array, second input arg. has ".concat(c,"th element, array ").concat(JSON.stringify(m,null,0),". Its second element is not an integer, string index, but ").concat(typeof m[1],", equal to: ").concat(JSON.stringify(m[1],null,4),"."));i[c][1]=+i[c][1]}s+=1});let g=$e(i,{progressFn:m=>{l&&(t=10+Math.floor(m/10),t!==a&&(a=t,l(t)))}});pe(g);let o=g.length;if(o>0){let m=e.slice(g[o-1][1]);e=g.reduce((c,y,h,$)=>{l&&(t=20+Math.floor(h/o*80),t!==a&&(a=t,l(t)));let O=h===0?0:$[h-1][1],C=$[h][0];return"".concat(c).concat(e.slice(O,C)).concat($[h][2]||"")},""),e+=m}return e}function Y(e,r=1){let l="\xA0";function t(i){return Array.from(i).reverse().join("")}function a(i,u,s){let g=s?"\n":"\r",o=s?"\r":"\n";if(!i)return i;let m=0,c=0,y="";for(let h=0,$=i.length;h<$;h++)(i[h]===g||i[h]===o&&i[h-1]!==g)&&c++,"\r\n".includes(i[h])||i[h]===l?(m=0,i[h]===l?y+=i[h]:i[h]===g?c<=u&&(y+=i[h],i[h+1]===o&&(y+=i[h+1],h++)):i[h]===o&&(i==null?void 0:i[h-1])!==g&&c<=u&&(y+=i[h])):(m++,!i[h+1]&&!c&&(y+=" "));return y}if(typeof e=="string"&&e.length){let i=1;typeof+r=="number"&&Number.isInteger(+r)&&+r>=0&&(i=+r);let u="",s="";if(!e.trim())u=e;else if(!e[0].trim()){for(let g=0,o=e.length;g<o;g++)if(e[g].trim()){u=e.slice(0,g);break}}if(e.trim()&&(e.slice(-1).trim()===""||e.slice(-1)===l)){for(let g=e.length;g--;)if(e[g].trim()){s=e.slice(g+1);break}}return"".concat(a(u,i,!1)).concat(e.trim()).concat(t(a(t(s),i,!0)))}return e}var Te=fe(ne(),1);var pt=(0,Te.default)();function F(e){return S(e)&&e.length===1&&e.toUpperCase()!==e.toLowerCase()}function M(e){if(e==null||typeof e!="object")return!1;let r=Object.getPrototypeOf(e);return r!==null&&r!==Object.prototype&&Object.getPrototypeOf(r)!==null?!1:!(Symbol.iterator in e)&&!(Symbol.toStringTag in e)}function S(e){return typeof e=="string"}function ye(e){return Number.isFinite(e)}function R(e){return Number.isSafeInteger(e)&&e>=0}function P(e){return e!=null}function Ee(e,r){return M(e)&&S(r)&&r in e}var Se={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function qe(e,r){var o;function l(m){return!!m&&typeof m=="object"&&!Array.isArray(m)}if(!Array.isArray(e)||!e.length)return null;let t;if(r)if(l(r)){if(t=w(w({},Se),r),t.progressFn&&l(t.progressFn)&&!Object.keys(t.progressFn).length)t.progressFn=null;else if(t.progressFn&&typeof t.progressFn!="function")throw new Error('ranges-merge: [THROW_ID_01] resolvedOpts.progressFn must be a function! It was given of a type: "'.concat(typeof t.progressFn,'", equal to ').concat(JSON.stringify(t.progressFn,null,4)));if(![1,2,"1","2"].includes(t.mergeType))throw new Error('ranges-merge: [THROW_ID_02] resolvedOpts.mergeType was customised to a wrong thing! It was given of a type: "'.concat(typeof t.mergeType,'", equal to ').concat(JSON.stringify(t.mergeType,null,4)));if(typeof t.joinRangesThatTouchEdges!="boolean")throw new Error('ranges-merge: [THROW_ID_04] resolvedOpts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "'.concat(typeof t.joinRangesThatTouchEdges,'", equal to ').concat(JSON.stringify(t.joinRangesThatTouchEdges,null,4)))}else throw new Error("ranges-merge: [THROW_ID_03] the second input argument must be a plain object. It was given as:\n".concat(JSON.stringify(r,null,4)," (type ").concat(typeof r,")"));else t=w({},Se);let a=e.filter(m=>Array.isArray(m)).map(m=>[...m]).filter(m=>m[2]!==void 0||m[0]!==m[1]),i,u,s;t.progressFn?i=k(a,{progressFn:m=>{s=Math.floor(m/5),s!==u&&(u=s,t.progressFn!=null&&t.progressFn(s))}}):i=k(a);let g=i.length-1;for(let m=g;m>0;m--)t.progressFn&&(s=Math.floor((1-m/g)*78)+21,s!==u&&s>u&&(u=s,t.progressFn(s))),(i[m][0]<=i[m-1][0]||!t.joinRangesThatTouchEdges&&i[m][0]<i[m-1][1]||t.joinRangesThatTouchEdges&&i[m][0]<=i[m-1][1])&&(i[m-1][0]=Math.min(i[m][0],i[m-1][0]),i[m-1][1]=Math.max(i[m][1],i[m-1][1]),i[m][2]!==void 0&&(i[m-1][0]>=i[m][0]||i[m-1][1]<=i[m][1])&&i[m-1][2]!==null&&(i[m][2]===null&&i[m-1][2]!==null?i[m-1][2]=null:i[m-1][2]!=null?+((o=t||{})==null?void 0:o.mergeType)==2&&i[m-1][0]===i[m][0]?i[m-1][2]=i[m][2]:i[m-1][2]+=i[m][2]:i[m-1][2]=i[m][2]),i.splice(m,1),m=i.length);return i.length?i:null}var Ye={limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1},Oe=class{constructor(e){ee(this,"ranges");ee(this,"opts");let r=w(w({},Ye),e);if(r.mergeType&&r.mergeType!==1&&r.mergeType!==2)if(S(r.mergeType)&&r.mergeType.trim()==="1")r.mergeType=1;else if(S(r.mergeType)&&r.mergeType.trim()==="2")r.mergeType=2;else throw new Error('ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "'.concat(typeof r.mergeType,'", equal to ').concat(JSON.stringify(r.mergeType,null,4)));this.opts=r,this.ranges=[]}add(e,r,l){var i;if(e==null&&r==null)return;if(P(e)&&!P(r)){if(Array.isArray(e)){if(e.length){if(e.some(u=>Array.isArray(u))){e.forEach(u=>{Array.isArray(u)&&this.add(...u)});return}e.length&&R(+e[0])&&R(+e[1])&&this.add(...e)}return}throw new TypeError('ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set ('.concat(JSON.stringify(e,null,0),') but second-one, "to" is not (').concat(JSON.stringify(r,null,0),")"))}else if(!P(e)&&P(r))throw new TypeError('ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set ('.concat(JSON.stringify(r,null,0),') but first-one, "from" is not (').concat(JSON.stringify(e,null,0),")"));let t=+e,a=+r;if(R(t)&&R(a)){if(P(l)&&!S(l)&&!ye(l))throw new TypeError("ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ".concat(typeof l,", equal to:\n").concat(JSON.stringify(l,null,4)));if(P(this.ranges)&&Array.isArray(this.last())&&t===this.last()[1]){if(this.last()[1]=a,this.last()[2],this.last()[2]!==null&&P(l)){let u=this.last()[2]&&this.last()[2].length&&(!((i=this.opts)!=null&&i.mergeType)||this.opts.mergeType===1)?"".concat(this.last()[2]).concat(l):l;this.opts.limitToBeAddedWhitespace&&(u=Y(u,this.opts.limitLinebreaksCount)),S(u)&&!u.length||(this.last()[2]=u)}}else{this.ranges||(this.ranges=[]);let u=l!==void 0&&!(S(l)&&!l.length)?[t,a,l&&this.opts.limitToBeAddedWhitespace?Y(l,this.opts.limitLinebreaksCount):l]:[t,a];this.ranges.push(u)}}else throw R(t)&&t>=0?new TypeError('ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it\'s of a type "'.concat(typeof a,'" equal to: ').concat(JSON.stringify(a,null,4))):new TypeError('ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it\'s of a type "'.concat(typeof t,'" equal to: ').concat(JSON.stringify(t,null,4)))}push(e,r,l){this.add(e,r,l)}current(){return Array.isArray(this.ranges)&&this.ranges.length?(this.ranges=qe(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map(e=>P(e[2])?[e[0],e[1],Y(e[2],this.opts.limitLinebreaksCount)]:e):this.ranges):null}wipe(){this.ranges=[]}replace(e){if(Array.isArray(e)&&e.length)if(Array.isArray(e[0])&&R(e[0][0]))this.ranges=Array.from(e);else throw new Error("ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ".concat(JSON.stringify(e[0],null,4)," should be an array and its first element should be an integer, a string index."));else this.ranges=[]}last(){return Array.isArray(this.ranges)&&this.ranges.length?this.ranges[this.ranges.length-1]:null}};function we(e){return typeof e!="string"?e:e.length?[e]:[]}var Le={cb:void 0,i:!1,trimBeforeMatching:!1,trimCharsBeforeMatching:[],maxMismatches:0,firstMustMatch:!1,lastMustMatch:!1,hungry:!1},Ke=e=>e+1;function ze(e,r,l,t,a=!1,i=Ke){var b;let u=typeof l=="function"?l():l;if(+r<0&&a&&u==="EOL")return u;let s=w(w({},Le),t);if(r>=e.length&&!a)return!1;let g=a?1:l.length,o=0,m=!1,c=!1,y=!1,h=s.maxMismatches,$=r,O=!1,C=!1,T=!1;function p(){return o===1&&h<s.maxMismatches-1}for(;e[$];){let d=i($);if(s.trimBeforeMatching&&e[$].trim()===""){if(!e[d]&&a&&l==="EOL")return!0;$=i($);continue}if(s&&!s.i&&((b=s==null?void 0:s.trimCharsBeforeMatching)!=null&&b.includes(e[$]))||s!=null&&s.i&&s.trimCharsBeforeMatching&&s.trimCharsBeforeMatching.map(N=>N.toLowerCase()).includes(e[$].toLowerCase())){if(a&&l==="EOL"&&!e[d])return!0;$=i($);continue}let D=d>$?l[l.length-g]:l[g-1];if(!s.i&&e[$]===D||s.i&&e[$].toLowerCase()===D.toLowerCase()){if(O||(O=!0),y||(y=!0),g===l.length){if(C=!0,h!==s.maxMismatches)return!1}else g===1&&(T=!0);if(g-=1,o++,p())return!1;if(!g)return o!==l.length||h===s.maxMismatches||!m?$:!1}else if(!m&&!o&&(m=!0),s.maxMismatches&&h&&$){h-=1;for(let N=0;N<=h;N++){let v=d>$?l[l.length-g+1+N]:l[g-2-N],V=e[i($)];if(v&&(!s.i&&e[$]===v||s.i&&e[$].toLowerCase()===v.toLowerCase())&&(!s.firstMustMatch||g!==l.length)){if(o++,p())return!1;g-=2,O=!0;break}else if(V&&v&&(!s.i&&V===v||s.i&&V.toLowerCase()===v.toLowerCase())&&(!s.firstMustMatch||g!==l.length)){if(!o&&!s.hungry)return!1;g-=1,O=!0;break}else if(v===void 0&&h>=0&&O&&(!s.firstMustMatch||C)&&(!s.lastMustMatch||T))return $}O||(c=$)}else return $===0&&g===1&&!s.lastMustMatch&&y?0:!1;if(c!==!1&&c!==$&&(c=!1),g<1)return $;$=i($)}if(g>0)return a&&u==="EOL"?!0:s&&s.maxMismatches>=g&&y?c||0:!1}function re(e,r,l,t,a){var m,c,y;if(M(a)&&Ee(a,"trimBeforeMatching")&&a&&typeof a.trimBeforeMatching!="boolean")throw new Error("string-match-left-right/".concat(e,"(): [THROW_ID_09] opts.trimBeforeMatching should be boolean!").concat(Array.isArray(a.trimBeforeMatching)?" Did you mean to use opts.trimCharsBeforeMatching?":""));let i=w(w({},Le),a);if(typeof i.trimCharsBeforeMatching=="string"&&(i.trimCharsBeforeMatching=we(i.trimCharsBeforeMatching)),i.trimCharsBeforeMatching=i.trimCharsBeforeMatching.map(h=>S(h)?h:String(h)),!S(r)||!r.length)return!1;if(!Number.isInteger(l)||l<0)throw new Error("string-match-left-right/".concat(e,"(): [THROW_ID_03] the second argument should be a natural number. Currently it's of a type: ").concat(typeof l,", equal to:\n").concat(JSON.stringify(l,null,4)));let u,s;if(S(t))u=[t];else if(Array.isArray(t))u=t;else if(!t)u=t;else if(typeof t=="function")u=[],u.push(t);else throw new Error("string-match-left-right/".concat(e,"(): [THROW_ID_05] the third argument, whatToMatch, is neither string nor array of strings! It's ").concat(typeof t,", equal to:\n").concat(JSON.stringify(t,null,4)));if(a&&!M(a))throw new Error("string-match-left-right/".concat(e,"(): [THROW_ID_06] the fourth argument, options object, should be a plain object. Currently it's of a type \"").concat(typeof a,'", and equal to:\n').concat(JSON.stringify(a,null,4)));let g=0,o="";if((m=i==null?void 0:i.trimCharsBeforeMatching)!=null&&m.some((h,$)=>h.length>1?(g=$,o=h,!0):!1))throw new Error("string-match-left-right/".concat(e,"(): [THROW_ID_07] the fourth argument, options object contains trimCharsBeforeMatching. It was meant to list the single characters but one of the entries at index ").concat(g," is longer than 1 character, ").concat(o.length," (equals to ").concat(o,"). Please split it into separate characters and put into array as separate elements."));if(!u||!Array.isArray(u)||Array.isArray(u)&&!u.length||Array.isArray(u)&&u.length===1&&S(u[0])&&!u[0].trim()){if(typeof i.cb=="function"){let $,O=l;if((e==="matchLeftIncl"||e==="matchRight")&&(O+=1),e[5]==="L")for(let b=O;b--;){let d=r[b];if((!i.trimBeforeMatching||i.trimBeforeMatching&&(d!=null&&d.trim()))&&(!((c=i.trimCharsBeforeMatching)!=null&&c.length)||d!==void 0&&!i.trimCharsBeforeMatching.includes(d))){$=b;break}}else if(e.startsWith("matchRight"))for(let b=O;b<r.length;b++){let d=r[b];if((!i.trimBeforeMatching||i.trimBeforeMatching&&d.trim())&&(!((y=i.trimCharsBeforeMatching)!=null&&y.length)||!i.trimCharsBeforeMatching.includes(d))){$=b;break}}if($===void 0)return!1;let C=r[$],T=$+1,p="";return T&&T>0&&(p=r.slice(0,T)),e[5]==="L"||$&&$>0&&(p=r.slice($)),i.cb(C,p,$)}let h="";throw a||(h=" More so, the whole options object, the fourth input argument, is missing!"),new Error("string-match-left-right/".concat(e,'(): [THROW_ID_08] the third argument, "whatToMatch", was given as an empty string. This means, you intend to match purely by a callback. The callback was not set though, the opts key "cb" is not set!').concat(h))}for(let h=0,$=u.length;h<$;h++){s=typeof u[h]=="function";let O=u[h],C,T,p="",b=l;e==="matchRight"?b+=1:e==="matchLeft"&&(b-=1);let d=ze(r,b,O,i,s,D=>e[5]==="L"?D-1:D+1);if(d&&s&&typeof O=="function"&&O()==="EOL")return O()&&(!i.cb||i.cb(C,p,T))?O():!1;if(Number.isInteger(d)&&(T=e.startsWith("matchLeft")?d-1:d+1,e[5]==="L"?p=r.slice(0,d):p=r.slice(T)),T<0&&(T=void 0),r[T]&&(C=r[T]),Number.isInteger(d)&&(!i.cb||i.cb(C,p,T)))return O}return!1}function De(e,r,l,t){return re("matchLeft",e,r,l,t)}function ie(e,r,l,t){return re("matchRightIncl",e,r,l,t)}function J(e,r,l,t){return re("matchRight",e,r,l,t)}var Qe={str:"",from:0,to:0,ifLeftSideIncludesThisThenCropTightly:"",ifLeftSideIncludesThisCropItToo:"",ifRightSideIncludesThisThenCropTightly:"",ifRightSideIncludesThisCropItToo:"",extendToOneSide:!1,wipeAllWhitespaceOnLeft:!1,wipeAllWhitespaceOnRight:!1,addSingleSpaceToPreventAccidentalConcatenation:!1};function K(e){var s,g;let r=/^[0-9a-zA-Z]+$/;function l(o){return S(o)&&!o.trim()}if(M(e)){if(!Object.keys(e).length)throw new Error('string-range-expander: [THROW_ID_02] Input must be a plain object but it\'s been given as a plain object without any keys. However, "from" and "to" settings are obligatory!')}else{let o;throw e===void 0?o="but it is missing completely.":e===null?o="but it was given as null.":o="but it was given as ".concat(typeof e,", equal to:\n").concat(JSON.stringify(e,null,4),"."),new Error("string-range-expander: [THROW_ID_01] Input must be a plain object ".concat(o))}if(!R(e.from))throw new Error("string-range-expander: [THROW_ID_03] The input's \"from\" value resolvedOpts.from, is not a number! It's been given as ".concat(typeof e.from,", equal to ").concat(JSON.stringify(e.from,null,0)));if(!R(e.to))throw new Error("string-range-expander: [THROW_ID_04] The input's \"to\" value resolvedOpts.to, is not a number! It's been given as ".concat(typeof e.to,", equal to ").concat(JSON.stringify(e.to,null,0)));if(e!=null&&e.str&&!e.str[e.from]&&e.from!==e.to)throw new Error('string-range-expander: [THROW_ID_05] The given input string resolvedOpts.str ("'.concat(e.str,'") must contain the character at index "from" ("').concat(e.from,'")'));if(e!=null&&e.str&&!e.str[e.to-1])throw new Error('string-range-expander: [THROW_ID_06] The given input string, resolvedOpts.str ("'.concat(e.str,'") must contain the character at index before "to" ("').concat(e.to-1,'")'));if(e.from>e.to)throw new Error('string-range-expander: [THROW_ID_07] The given "from" index, "'.concat(e.from,'" is greater than "to" index, "').concat(e.to,"\". That's wrong!"));if(e.extendToOneSide===null||S(e.extendToOneSide)&&e.extendToOneSide!=="left"&&e.extendToOneSide!=="right"||!S(e.extendToOneSide)&&e.extendToOneSide!==void 0&&e.extendToOneSide)throw new Error('string-range-expander: [THROW_ID_08] The options value "extendToOneSide" is not recognisable! It\'s set to: "'.concat(e.extendToOneSide,'" (').concat(typeof e.extendToOneSide,'). It has to be either Boolean "false" or one of strings: "left" or "right"'));if(e!=null&&e.ifLeftSideIncludesThisThenCropTightly&&!S(e.ifLeftSideIncludesThisThenCropTightly))throw new Error('string-range-expander: [THROW_ID_09] The option "ifLeftSideIncludesThisThenCropTightly", is not a string! It\'s been given as '.concat(typeof e.ifLeftSideIncludesThisThenCropTightly,", equal to ").concat(JSON.stringify(e.ifLeftSideIncludesThisThenCropTightly,null,0)));if(e!=null&&e.ifLeftSideIncludesThisCropItToo&&!S(e.ifLeftSideIncludesThisCropItToo))throw new Error('string-range-expander: [THROW_ID_10] The option "ifLeftSideIncludesThisCropItToo", is not a string! It\'s been given as '.concat(typeof e.ifLeftSideIncludesThisCropItToo,", equal to ").concat(JSON.stringify(e.ifLeftSideIncludesThisCropItToo,null,0)));if(e!=null&&e.ifRightSideIncludesThisThenCropTightly&&!S(e.ifRightSideIncludesThisThenCropTightly))throw new Error('string-range-expander: [THROW_ID_11] The option "ifRightSideIncludesThisThenCropTightly", is not a string! It\'s been given as '.concat(typeof e.ifRightSideIncludesThisThenCropTightly,", equal to ").concat(JSON.stringify(e.ifRightSideIncludesThisThenCropTightly,null,0)));if(e!=null&&e.ifRightSideIncludesThisCropItToo&&!S(e.ifRightSideIncludesThisCropItToo))throw new Error('string-range-expander: [THROW_ID_12] The option "ifRightSideIncludesThisCropItToo", is not a string! It\'s been given as '.concat(typeof e.ifRightSideIncludesThisCropItToo,", equal to ").concat(JSON.stringify(e.ifRightSideIncludesThisCropItToo,null,0)));let t=w(w({},Qe),e),a=t.str,i=t.from,u=t.to;if(t.extendToOneSide!=="right"&&(l(a[i-1])&&(l(a[i-2])||t.ifLeftSideIncludesThisCropItToo.includes(a[i-2]))||a[i-1]&&t.ifLeftSideIncludesThisCropItToo.includes(a[i-1])||t.wipeAllWhitespaceOnLeft&&l(a[i-1]))){for(let o=i;o--;)if(!t.ifLeftSideIncludesThisCropItToo.includes(a[o])){if(a[o].trim()){t.wipeAllWhitespaceOnLeft||t.ifLeftSideIncludesThisCropItToo.includes(a[o+1])?i=o+1:i=o+2;break}else if(o===0){t.wipeAllWhitespaceOnLeft?i=0:i=1;break}}}if(t.extendToOneSide!=="left"&&(l(a[u])&&(t.wipeAllWhitespaceOnRight||l(a[u+1]))||t.ifRightSideIncludesThisCropItToo.includes(a[u]))){for(let o=u,m=a.length;o<m;o++)if(!t.ifRightSideIncludesThisCropItToo.includes(a[o])){if(a[o].trim()){t.wipeAllWhitespaceOnRight||t.ifRightSideIncludesThisCropItToo.includes(a[o-1])?u=o:u=o-1;break}else if(o===a.length-1){t.wipeAllWhitespaceOnRight?u=a.length:u=a.length-1;break}}}return(t.extendToOneSide!=="right"&&S(t.ifLeftSideIncludesThisThenCropTightly)&&t.ifLeftSideIncludesThisThenCropTightly&&(a[i-2]&&t.ifLeftSideIncludesThisThenCropTightly.includes(a[i-2])||a[i-1]&&t.ifLeftSideIncludesThisThenCropTightly.includes(a[i-1]))||t.extendToOneSide!=="left"&&S(t.ifRightSideIncludesThisThenCropTightly)&&t.ifRightSideIncludesThisThenCropTightly&&(a[u+1]&&t.ifRightSideIncludesThisThenCropTightly.includes(a[u+1])||a[u]&&t.ifRightSideIncludesThisThenCropTightly.includes(a[u])))&&(t.extendToOneSide!=="right"&&l(a[i-1])&&!t.wipeAllWhitespaceOnLeft&&(i-=1),t.extendToOneSide!=="left"&&l(a[u])&&!t.wipeAllWhitespaceOnRight&&(u+=1)),t.addSingleSpaceToPreventAccidentalConcatenation&&((s=a[i-1])!=null&&s.trim())&&((g=a[u])!=null&&g.trim())&&(!t.ifLeftSideIncludesThisThenCropTightly&&!t.ifRightSideIncludesThisThenCropTightly||!((!t.ifLeftSideIncludesThisThenCropTightly||t.ifLeftSideIncludesThisThenCropTightly.includes(a[i-1]))&&(!t.ifRightSideIncludesThisThenCropTightly||a[u]&&t.ifRightSideIncludesThisThenCropTightly.includes(a[u]))))&&(r.test(a[i-1])||r.test(a[u]))?[i,u," "]:[i,u]}var Ae=fe(ne(),1);var Vt=(0,Ae.default)();var B="\xA0";function Xe({str:e,idx:r=0,stopAtNewlines:l=!1,stopAtRawNbsp:t=!1}){if(typeof e!="string"||!e.length||((!r||typeof r!="number")&&(r=0),!e[r+1]))return null;if(e[r+1]&&(e[r+1].trim()||l&&"\n\r".includes(e[r+1])||t&&e[r+1]===B))return r+1;if(e[r+2]&&(e[r+2].trim()||l&&"\n\r".includes(e[r+2])||t&&e[r+2]===B))return r+2;for(let a=r+1,i=e.length;a<i;a++)if(e[a].trim()||l&&"\n\r".includes(e[a])||t&&e[a]===B)return a;return null}function L(e,r=0){return Xe({str:e,idx:r,stopAtNewlines:!1,stopAtRawNbsp:!1})}function Ze({str:e,idx:r,stopAtNewlines:l,stopAtRawNbsp:t}){if(typeof e!="string"||!e.length||((!r||typeof r!="number")&&(r=0),r<1))return null;if(e[~-r]&&(e[~-r].trim()||l&&"\n\r".includes(e[~-r])||t&&e[~-r]===B))return~-r;if(e[r-2]&&(e[r-2].trim()||l&&"\n\r".includes(e[r-2])||t&&e[r-2]===B))return r-2;for(let a=r;a--;)if(e[a]&&(e[a].trim()||l&&"\n\r".includes(e[a])||t&&e[a]===B))return a;return null}function z(e,r=0){return Ze({str:e,idx:r,stopAtNewlines:!1,stopAtRawNbsp:!1})}var Ie="6.1.0";var tt=Ie,E=new Oe({limitToBeAddedWhitespace:!0}),Ce={lineLengthLimit:500,removeIndentations:!0,removeLineBreaks:!1,removeHTMLComments:!1,removeCSSComments:!0,reportProgressFunc:null,reportProgressFuncFrom:0,reportProgressFuncTo:100,breakToTheLeftOf:["</td","<html","</html","<head","</head","<meta","<link","<table","<script","<\/script","<!DOCTYPE","<style","</style","<title","<body","@media","</body","<!--[if","<!--<![endif","<![endif]"],mindTheInlineTags:["a","abbr","acronym","audio","b","bdi","bdo","big","br","button","canvas","cite","code","data","datalist","del","dfn","em","embed","i","iframe","img","input","ins","kbd","label","map","mark","meter","noscript","object","output","picture","progress","q","ruby","s","samp","script","select","slot","small","span","strong","sub","sup","svg","template","textarea","time","u","tt","var","video","wbr"]};function nt(e,r){var ue,ae;let l=Date.now();if(!S(e))throw e===void 0?new Error("html-crush: [THROW_ID_01] the first input argument is completely missing! It should be given as string."):new Error('html-crush: [THROW_ID_02] the first input argument must be string! It was given as "'.concat(typeof e,'", equal to:\n').concat(JSON.stringify(e,null,4)));if(r&&!M(r))throw new Error("html-crush: [THROW_ID_03] the second input argument, options object, should be a plain object but it was given as type ".concat(typeof r,", equal to ").concat(JSON.stringify(r,null,4)));if(r&&Array.isArray(r.breakToTheLeftOf)&&r.breakToTheLeftOf.length){for(let n=0,U=r.breakToTheLeftOf.length;n<U;n++)if(!S(r.breakToTheLeftOf[n]))throw new TypeError("html-crush: [THROW_ID_05] the resolvedOpts.breakToTheLeftOf array contains non-string elements! For example, element at index ".concat(n,' is of a type "').concat(typeof r.breakToTheLeftOf[n],'" and is equal to:\n').concat(JSON.stringify(r.breakToTheLeftOf[n],null,4)))}let t=w(w({},Ce),r);typeof t.removeHTMLComments=="boolean"&&(t.removeHTMLComments=t.removeHTMLComments?1:0);let a="";Array.isArray(t.breakToTheLeftOf)&&t.breakToTheLeftOf.length&&(a=[...new Set(t.breakToTheLeftOf.map(n=>n[0]))].join(""));let i={removeHTMLComments:!1,removeCSSComments:!1},u=null,s=null,g=!1,o=0,m=0,c=!1,y=!1,h=null,$=null,O=null,C=null,T,p=null,b=null,d=null,D=null,N=null,v=null,V=">};",j="<",Ne="!",ve=">",Re="<",oe="{},:;<>~+",Q=oe,X=oe,_=!0,I=e.length,Ve=Math.floor(I/2),se=.01,le;t.reportProgressFunc&&(le=Math.floor(t.reportProgressFuncTo-(t.reportProgressFuncTo-t.reportProgressFuncFrom)*se-t.reportProgressFuncFrom));let H,q=0,A="\n";if(e.includes("\r\n")?A="\r\n":e.includes("\r")&&(A="\r"),I){for(let n=0;n<I;n++){if(t.reportProgressFunc&&(I>1e3&&I<2e3?n===Ve&&t.reportProgressFunc(Math.floor((t.reportProgressFuncTo-t.reportProgressFuncFrom)/2)):I>=2e3&&(H=t.reportProgressFuncFrom+Math.floor(n/I*(le||1)),H!==q&&(q=H,t.reportProgressFunc(H)))),m++,!T&&c&&e[n]==="}"&&e[n-1]==="}"&&(o+1>=t.lineLengthLimit?(E.push(n,n,A),o=0):(p=n,b=n,d=" ")),T&&typeof T=="number"&&n>=T&&(T=void 0),C!==null&&e.startsWith("<\/script",n)&&!F(e[n+8])){if((t.removeIndentations||t.removeLineBreaks)&&n>0&&e[~-n]&&!e[~-n].trim()){for(let f=n;f--;)if(e[f]==="\n"||e[f]==="\r"||e[f].trim()){f+1<n&&E.push(f+1,n);break}}C=null,T=!1,n+=8;continue}if(!T&&!c&&e.startsWith("<script",n)&&!F(e[n+7])){C=n,T=!0;let f="";(t.removeLineBreaks||t.removeIndentations)&&s!==null&&(s>0&&(f=A),E.push(s,n,f)),s=null,u=null}if(N!==null&&D===null&&!/\w/.test(e[n])){D=e.slice(N,n);let f=L(e,~-n);typeof f=="number"&&e[f]===">"&&!e[n].trim()&&L(e,n)?E.push(n,L(e,n)):f&&e[f]==="/"&&e[L(e,f)]===">"&&(!e[n].trim()&&L(e,n)&&E.push(n,L(e,n)),e[f+1]!==">"&&L(e,f+1)&&E.push(f+1,L(e,f+1)))}if(!T&&!c&&!h&&e[~-n]==="<"&&N===null&&(/\w/.test(e[n])?N=n:e[L(e,~-n)]==="/"&&/\w/.test(e[L(e,L(e,~-n))]||"")&&(N=L(e,L(e,~-n)))),!T&&(c||h)&&$!==null&&e[n]==="*"&&e[n+1]==="/"&&([p,b]=K({str:e,from:$,to:n+2,ifLeftSideIncludesThisThenCropTightly:Q||"",ifRightSideIncludesThisThenCropTightly:X||""}),$=null,p!=null?E.push(p,b):(o+=1,n+=1),T=n+2),!T&&(c||h)&&$===null&&e[n]==="/"&&e[n+1]==="*"&&(i.removeCSSComments||(i.removeCSSComments=!0),t.removeCSSComments&&($=n)),y&&e.startsWith("![endif",n+1)&&(y=!1),!T&&!c&&!h&&O!==null){let f;e.startsWith("-->",n)?f=3:e[n]===">"&&e[n-1]==="]"&&(f=1),f&&([p,b]=K({str:e,from:O,to:n+f}),O=null,p!=null?t.lineLengthLimit&&m-(b-p)>=t.lineLengthLimit?(E.push(p,b,A),m=-f):(E.push(p,b),m-=b-p):(o+=f-1,n+=f-1),T=n+f)}if(!T&&!c&&!h&&(e.startsWith("<!--",n)||t.removeHTMLComments===2&&e.startsWith("<![endif",n))&&O===null&&(e.startsWith("[if",n+4)?(y||(y=!0),t.removeHTMLComments===2&&(O=n)):t.removeHTMLComments&&(!y||t.removeHTMLComments===2)&&(O=n),i.removeHTMLComments||(i.removeHTMLComments=!0)),!T&&c&&$===null&&e.startsWith("</style",n)&&!F(e[n+7])?c=!1:!T&&!c&&$===null&&e.startsWith("<style",n)&&!F(e[n+6])&&(c=!0,(t.removeLineBreaks||t.removeIndentations)&&t.breakToTheLeftOf.includes("<style")&&e.startsWith(' type="text/css">',n+6)&&e[n+24]&&E.push(n+23,n+23,A)),!T&&!h&&"\"'".includes(e[n])&&e.endsWith("style=",n)&&(h=n),!T&&!e[n].trim())s===null&&(s=n);else if(!T&&!((c||h)&&$!==null)){if(s!==null){if(t.removeLineBreaks&&(o+=1),_)_=!1,(t.removeIndentations||t.removeLineBreaks)&&E.push(0,n);else if(t.removeIndentations&&!t.removeLineBreaks&&(!g&&u!==null&&n>u?E.push(u+1,n):s+1<n&&(e.endsWith("]>",s)||e.endsWith("-->",s)||e.startsWith("<![",n)||e.startsWith("<!--<![",n)?E.push(s,n):e[s]===" "?E.push(s+1,n):e[~-n]===" "?E.push(s,~-n):E.push(s,n," "))),t.removeLineBreaks||h){if(a.includes(e[n])&&ie(e,n,t.breakToTheLeftOf)){!("\r\n".includes(e[~-n])&&s===~-n)&&!(e[~-n]==="\n"&&e[n-2]==="\r"&&s===n-2)&&E.push(s,n,A),p=null,b=null,d=null,s=null,o=1;continue}let f=" ";e[n]==="<"&&J(e,n,t.mindTheInlineTags,{cb:x=>!x||!/\w/.test(x)})||(e[~-s]&&ve.includes(e[~-s])&&Re.includes(e[n])||(c||h)&&$===null&&(Q.includes(e[~-s])||X.includes(e[n]))||e.startsWith("!important",n)&&!y||h&&(e[~-s]==="'"||e[~-s]==='"')||e[~-s]==="}"&&e.startsWith("</style",n)||e[n]===">"&&("'\"".includes(e[z(e,n)])||e[L(e,n)]==="<")||e[n]==="/"&&e[L(e,n)]===">")&&(f="",e[n]==="/"&&e[n+1]===">"&&L(e,n)&&L(e,n)>n+1&&(E.push(n+1,L(e,n)),o-=L(e,n)-n+1)),c&&e[n]==="}"&&s&&e[s-1]==="}"&&(f=" "),f!=null&&f.length&&(o+=1),t.lineLengthLimit?o>=t.lineLengthLimit||!e[n+1]||e[n]===">"||e[n]==="/"&&e[n+1]===">"?((o>t.lineLengthLimit||o===t.lineLengthLimit&&((ue=e[n+1])!=null&&ue.trim())&&!V.includes(e[n])&&!j.includes(e[n+1]))&&(f=A,o=1),(o>t.lineLengthLimit||!(f===" "&&n===s+1))&&(E.push(s,n,f),u=null),p=null,b=null,d=null):(p===null||s<p)&&(p=s,b=n,d=f):n===s+1&&f===" "||E.push(s,n,f)}s=null,g||(g=!0)}else _&&(_=!1),t.removeLineBreaks&&(o+=1);g||(g=!0)}if(!T&&!_&&n!==0&&t.removeLineBreaks&&(t.lineLengthLimit||a)&&!e.startsWith("</a",n)){if(a&&ie(e,n,t.breakToTheLeftOf)&&e.slice(0,n).trim()&&(!e.startsWith("<![endif]",n)||!De(e,n,"<!--"))){E.push(n,n,A),p=null,b=null,d=null,o=1;continue}else if(t.lineLengthLimit&&o<=t.lineLengthLimit){if(!e[n+1]||j.includes(e[n])&&!Ne.includes(e[n])||V.includes(e[n])||!e[n].trim()){if(p!==null&&b!==null&&(p!==b||d!=null&&d.length)){let f=d;e[n].trim()&&((ae=e[n+1])!=null&&ae.trim())&&o+(d?d.length:0)>t.lineLengthLimit&&(f=A),(o+(f?f.length:0)>t.lineLengthLimit||!(f===" "&&b===p+1&&e[p]===" "))&&(e[~-p]==="}"&&e[b]==="{"||(E.push(p,b,f),u=null))}e[n].trim()&&(j.includes(e[n])||e[~-n]&&V.includes(e[~-n]))&&S(v)&&(!D||!t.mindTheInlineTags.includes(D))&&!(e[n]==="<"&&J(e,n,t.mindTheInlineTags,{cb:f=>!f||!/\w/.test(f)}))&&!(e[n]==="<"&&J(e,n,t.mindTheInlineTags,{trimCharsBeforeMatching:"/",cb:f=>!f||!/\w/.test(f)}))?(p=n,b=n,d=null):$===null&&p!==null&&(h||!t.mindTheInlineTags||!Array.isArray(t.mindTheInlineTags)||Array.isArray(t.mindTheInlineTags.length)&&!t.mindTheInlineTags.length||!S(D)||Array.isArray(t.mindTheInlineTags)&&t.mindTheInlineTags.length&&S(D)&&!t.mindTheInlineTags.includes(D))&&!(e[n]==="<"&&J(e,n,t.mindTheInlineTags,{trimCharsBeforeMatching:"/",cb:f=>!f||!/\w/.test(f)}))&&(p=null,b=null,d=null)}}else if(t.lineLengthLimit)if(j.includes(e[n])&&!(e[n]==="<"&&J(e,n,t.mindTheInlineTags,{trimCharsBeforeMatching:"/",cb:f=>!f||!/\w/.test(f)})))if(p!==null&&b!==null&&(p!==b||d!=null&&d.length)){let f=d!=null&&d.length?d.length:0;o-(b-p-f)-1>t.lineLengthLimit||(E.push(p,b,d),o-(b-p-f)-1===t.lineLengthLimit&&(E.push(n,n,A),o=0),p=null,b=null,d=null)}else E.push(n,n,A),o=0;else e[n+1]&&V.includes(e[n])&&S(D)&&Array.isArray(t.mindTheInlineTags)&&t.mindTheInlineTags.length&&!t.mindTheInlineTags.includes(D)?p!==null&&b!==null&&(p!==b||d!=null&&d.length)||(E.push(n+1,n+1,A),o=0):e[n].trim()&&(e[n+1]||p!==null&&b!==null&&(p!==b||d!=null&&d.length)&&E.push(p,b,A))}if(!T&&!_&&t.removeLineBreaks&&t.lineLengthLimit&&o>=t.lineLengthLimit&&p!==null&&b!==null&&!V.includes(e[n])&&!j.includes(e[n])&&!"/".includes(e[n])&&!(o===t.lineLengthLimit&&e[n+1]&&!e[n+1].trim())){let f=A;e[n+1]&&!e[n+1].trim()&&o===t.lineLengthLimit&&(f=d),f===A&&!e[~-p].trim()&&z(e,p)&&(p=z(e,p)+1),E.push(p,b,f),o=n-b,e[n].length&&(o+=1),p=null,b=null,d=null}if((!T&&e[n]==="\n"||e[n]==="\r"&&(!e[n+1]||e[n+1]&&e[n+1]!=="\n"))&&(u=n,g&&(g=!1),!t.removeLineBreaks&&s!==null&&s<n&&e[n+1]&&e[n+1]!=="\r"&&e[n+1]!=="\n"&&E.push(s,n)),e[n+1]||(c&&$!==null?E.push([...K({str:e,from:$,to:n,ifLeftSideIncludesThisThenCropTightly:Q||"",ifRightSideIncludesThisThenCropTightly:X||""})]):s&&e[n]!=="\n"&&e[n]!=="\r"?E.push(s,n+1):s&&(e[n]==="\r"&&e[n+1]==="\n"||e[n]==="\n"&&e[n-1]!=="\r")&&E.push(s,n)),!T&&h&&h<n&&e[h]===e[n]&&(h=null),!T&&!c&&e.startsWith("<pre",n)&&!F(e[n+4])){let f=e.indexOf("</pre",n+5);f>0&&(T=f)}if(!T&&!c&&e.startsWith("<code",n)&&!F(e[n+5])){let f=e.indexOf("</code",n+5);f>0&&(T=f)}if(!T&&e.startsWith("<![CDATA[",n)){let f=e.indexOf("]]>",n+9);f>0&&(T=f)}!T&&!c&&!h&&N!==null&&e[n]===">"&&(e[L(e,n)]==="<"&&(v=D),N=null,D=null),e[n]==="<"&&v!==null&&(v=null),c&&e[n]==="{"&&e[n+1]==="{"&&e.indexOf("}}")!==-1&&(T=e.indexOf("}}")+2);let U=!0}if(E.current()){let n=E.current();E.wipe();let U=t.reportProgressFuncTo-(t.reportProgressFuncTo-t.reportProgressFuncFrom)*se,f=de(e,n,Me=>{t.reportProgressFunc&&I>=2e3&&(H=Math.floor(U+(t.reportProgressFuncTo-U)*(Me/100)),H!==q&&(q=H,t.reportProgressFunc(H)))}),x=f.length;return{log:{timeTakenInMilliseconds:Date.now()-l,originalLength:I,cleanedLength:x,bytesSaved:Math.max(I-x,0),percentageReducedOfOriginal:I?Math.round(Math.max(I-x,0)*100/I):0},ranges:n,applicableOpts:i,result:f}}}return{log:{timeTakenInMilliseconds:Date.now()-l,originalLength:I,cleanedLength:I,bytesSaved:0,percentageReducedOfOriginal:0},applicableOpts:i,ranges:null,result:e}}return Je(rt);})();
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 6.1.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
/**
 * @name ranges-merge
 * @fileoverview Merge and sort string index ranges
 * @version 9.1.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/ranges-merge/}
 */
/**
 * @name ranges-apply
 * @fileoverview Take an array of string index ranges, delete/replace the string according to them
 * @version 7.1.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/ranges-apply/}
 */
/**
 * @name string-collapse-leading-whitespace
 * @fileoverview Collapse the leading and trailing whitespace of a string
 * @version 7.1.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/string-collapse-leading-whitespace/}
 */
/**
 * @name codsen-utils
 * @fileoverview Various utility functions
 * @version 1.7.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/codsen-utils/}
 */
/**
 * @name ranges-push
 * @fileoverview Gather string index ranges
 * @version 7.1.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/ranges-push/}
 */
/**
 * @name arrayiffy-if-string
 * @fileoverview Put non-empty strings into arrays, turn empty-ones into empty arrays. Bypass everything else.
 * @version 5.1.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/arrayiffy-if-string/}
 */
/**
 * @name string-match-left-right
 * @fileoverview Match substrings on the left or right of a given index, ignoring whitespace
 * @version 9.1.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/string-match-left-right/}
 */
/**
 * @name string-range-expander
 * @fileoverview Expands string index ranges within whitespace boundaries until letters are met
 * @version 4.1.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/string-range-expander/}
 */
/**
 * @name string-left-right
 * @fileoverview Looks up the first non-whitespace character to the left/right of a given index
 * @version 6.1.0
 * @author Roy Revelt
 * @license MIT
 * {@link https://codsen.com/os/string-left-right/}
 */
